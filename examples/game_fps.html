<!DOCTYPE html>
<html lang="en">
	<head>
		<title>HYPER - game_fps</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="css/style.css">
	</head>
	<body>

		<script src="js/jquery.min.js"></script>
		<script src="js/jquery.mousecapture.js"></script>
		<script src="js/bundle.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="js/framework.js"></script>

		<script>
			var intersects = require('threejs-geometry-hittest').intersects;
			runExample(function (fw) {
				var renderer = fw.renderer;
				var camera = fw.autoCameraAspect(new THREE.PerspectiveCamera(70, 1, 0.1, 50));
				camera.up.set(0, 0, 1);

				// Geometry which clips the movement of players
				var playerClipGeometry;
				var playerClipObject;

				var t1 = new THREE.Vector3();
				var t2 = new THREE.Vector3();

				function Player()
				{
					this.pos = new THREE.Vector3(9.41, 0, -14.8263);
					this.vel = new THREE.Vector3(0, 0, 0);
					this.yaw = 0;
					this.pitch = 0;
					this.height = 1.7;
					this.eyeHeight = 1.6;
					this.radius = 0.4;
					this.control = new THREE.Vector2(0, 0);
					this.jump = false;
				}
				Player.prototype = {
					getFront: function ()
					{
						var yaw = this.yaw, pitch = this.pitch;
						return new THREE.Vector3(
							Math.sin(yaw) * Math.cos(pitch),
							-Math.sin(pitch),
							-Math.cos(yaw) * Math.cos(pitch));
					},
					getSide: function ()
					{
						var yaw = this.yaw;
						return new THREE.Vector3(
							Math.cos(yaw),
							0,
							Math.sin(yaw));
					},
					getFrontNoPitch: function ()
					{
						var yaw = this.yaw;
						return new THREE.Vector3(
							Math.sin(yaw),
							0,
							-Math.cos(yaw));
					},
					getBox: function ()
					{
						var pos = this.pos;
						var min = new THREE.Vector3(
							pos.x - this.radius,
							pos.y,
							pos.z - this.radius
						);
						var max = new THREE.Vector3(
							pos.x + this.radius,
							pos.y + this.eyeHeight,
							pos.z + this.radius
						);
						return new THREE.Box3(min, max);
					},
					update: function (deltaTime)
					{
						this.pos.addScaledVector(this.vel, deltaTime);

						// friction
						this.vel.x *= Math.pow(0.0001, deltaTime);
						this.vel.z *= Math.pow(0.0001, deltaTime);

						// gravity
						this.vel.y -= 20 * deltaTime;

						this.vel.addScaledVector(this.getFrontNoPitch(), this.control.y * 40 * deltaTime);
						this.vel.addScaledVector(this.getSide(), this.control.x * 40 * deltaTime);

						// floor
						var caster = new THREE.Raycaster();
						caster.near = 0; caster.far = this.radius;
						caster.set(new THREE.Vector3(
							this.pos.x, this.pos.y + this.radius, this.pos.z),
							new THREE.Vector3(0, -1, 0));
						var ins = caster.intersectObjects([playerClipObject]);
						var minDistance = Infinity;
						for (var i = 0; i < ins.length; ++i) {
							minDistance = Math.min(minDistance, ins[i].distance);
						}
						if (minDistance >= 0 && minDistance <= this.radius + 0.001) {
							this.pos.y += this.radius - minDistance;
							this.vel.y = Math.max(this.vel.y, 0);
							if (this.jump) {
								this.vel.y = 10;
							}
						}

						// wall
						function clip(sph)
						{
							var geo = playerClipGeometry;
							var results = intersects(geo, sph);
							var center = sph.center;
							for (var i = 0; i < results.length; ++i) {
								var r = results[i];
								var face = geo.faces[r.faceIndex];

								// get away from the wall
								var d = r.pos.sub(center).normalize();
								this.pos.addScaledVector(d, -r.depth);

								// stop movement toward the wall
								var k = this.vel.dot(d);
								if (k > 0) {
									this.vel.addScaledVector(d, -k);
								}
							}
							return results.length;
						}

						for (var i = 0; i < 3; ++i) {
							var hit = false;

							var p = this.pos.clone();
							p.y += this.radius * 1.8;
							if (clip.call(this, new THREE.Sphere(p, this.radius))) hit = true;
							p.copy(this.pos);
							p.y += this.height * .5;
							if (clip.call(this, new THREE.Sphere(p, this.radius))) hit = true;
							p.copy(this.pos);
							p.y += this.height - this.radius;
							if (clip.call(this, new THREE.Sphere(p, this.radius))) hit = true;

							if (!hit)
								break;
						}
					},
					moveCamera: function (camera)
					{
						var pos = this.pos;
						camera.position.set(pos.x, pos.y + this.eyeHeight, pos.z);
               			camera.quaternion.setFromEuler(new THREE.Euler(
               				-this.pitch, -this.yaw, 0, 'YXZ'));
					}
				};


				var scene = new THREE.Scene();


				var texture = THREE.ImageUtils.loadTexture( 'textures/crate.jpg' );
				var textureSp = THREE.ImageUtils.loadTexture( 'textures/crate-specular.jpg' );

				var skygeo = new THREE.BoxGeometry( 70, 70, 70 );
				for (var i = 0; i < skygeo.faces.length; ++i) {
					var face = skygeo.faces[i];
					var k = face.a;
					for (var j = 0; j < 3; ++j) {
						face.vertexNormals[j].negate();
					}
					face.a = face.b; face.b = k;
				}
				for (var i = 0; i < skygeo.vertices.length; ++i) {
					var v = skygeo.vertices[i];
				}
				
				var skyMaterial = new THREE.MeshBasicMaterial({
					color: 0x9fcfff
				});

				mesh = new THREE.Mesh(skygeo, skyMaterial);
				camera.add( mesh );

				var sungeo = new THREE.SphereGeometry(0.7, 16, 16);
				var suncolor = new THREE.Color();
				suncolor.r = 20; suncolor.g = 17; suncolor.b = 14;
				var sun = new THREE.Mesh(sungeo, new THREE.MeshBasicMaterial({color: suncolor}));
				scene.add(sun);

				var levelMesh;

				var jsonLoader = new THREE.JSONLoader();
				jsonLoader.load('models/level.json', function (geo, mats) {

					var material = new THREE.MeshPhongMaterial({
						//map: texture,
						//specularMap: textureSp,
						color: 0x3f3f3f,
						shininess: 100
					});

					levelMesh = new THREE.Mesh(geo, material);
					levelMesh.castShadow = true;
					scene.add(levelMesh);

					playerClipGeometry = geo;
					playerClipObject = levelMesh;
				});

				var sunLight = new THREE.DirectionalLight(0xffefdf, 2);
				sunLight.position.set(2, 2, -1);
				sunLight.castShadow = true;
				scene.add(sunLight);

				var flashlight = new THREE.PointLight(0xffaf6f, 10, 10);
				flashlight.position.set(0, 0.1, -0.5);
				flashlight.castShadow = true;
				//camera.add(flashlight);

				var ambLight = new THREE.AmbientLight(0x9fcfff);
				scene.add(ambLight);

				scene.add(camera);

				// generate players
				var human = new Player();

                fw.on('lockedmousemove', function (e) {
                	var yaw = human.yaw, pitch = human.pitch;
                    yaw += e.dx * 0.004;
                    pitch += e.dy * 0.004;
                    pitch = Math.max(Math.min(pitch, Math.PI * 0.49), Math.PI * -0.49);
                    human.yaw = yaw; human.pitch = pitch;
                });

				fw.on('animate', function (e) {
					// update players after map is loaded
					if (playerClipGeometry) {
						var ctrl = human.control;
						ctrl.x = ctrl.y = 0;
	                    if (fw.isKeyPressed('w')) ctrl.y = 1;
	                    if (fw.isKeyPressed('s')) ctrl.y = -1;
	                    if (fw.isKeyPressed('a')) ctrl.x = -1;
	                    if (fw.isKeyPressed('d')) ctrl.x = 1;
	                    human.jump = fw.isKeyPressed(' ');

	                    human.update(e.deltaTime);
					}

					human.moveCamera(camera);
					sun.position.copy(camera.position);
					sun.position.addScaledVector(sunLight.position, 5)

					renderer.render( scene, camera );
				});

			});

		</script>

	</body>
</html>
